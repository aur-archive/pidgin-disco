--- libpurple/disco.c 7b08cba2694eab268ca987664f70a6b9ff9738e5
+++ libpurple/disco.c 7b08cba2694eab268ca987664f70a6b9ff9738e5
@@ -0,0 +1,257 @@
+/**
+ * @file disco.c Service Discovery API
+ * @ingroup core
+ */
+
+/* purple
+ *
+ * Purple is the legal property of its developers, whose names are too numerous
+ * to list here.  Please refer to the COPYRIGHT file distributed with this
+ * source distribution.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111-1301  USA
+ */
+
+#include "internal.h"
+#include "debug.h"
+
+#include "disco.h"
+
+static PurpleDiscoUiOps *ops = NULL;
+
+PurpleDiscoList *purple_disco_list_new(PurpleAccount *account, void *ui_data)
+{
+        PurpleDiscoList *list;
+
+        g_return_val_if_fail(account != NULL, NULL);
+
+        list = g_new0(PurpleDiscoList, 1);
+        list->account = account;
+        list->ref = 1;
+        list->ui_data = ui_data;
+
+        if (ops && ops->create)
+                ops->create(list);
+
+        return list;
+}
+
+void purple_disco_list_ref(PurpleDiscoList *list)
+{
+        g_return_if_fail(list != NULL);
+
+        list->ref++;
+        purple_debug_misc("disco", "reffing list, ref count now %d\n", list->ref);
+}
+
+static void purple_disco_list_service_destroy(PurpleDiscoList *list, PurpleDiscoService *r)
+{
+        g_free(r->name);
+        g_free(r->description);
+        g_free(r);
+}
+
+static void purple_disco_list_destroy(PurpleDiscoList *list)
+{
+        GList *l;
+
+        purple_debug_misc("disco", "destroying list %p\n", list);
+
+        if (ops && ops->destroy)
+                ops->destroy(list);
+
+        for (l = list->services; l; l = l->next) {
+                PurpleDiscoService *s = l->data;
+                purple_disco_list_service_destroy(list, s);
+        }
+        g_list_free(list->services);
+
+        g_free(list);
+}
+
+void purple_disco_list_unref(PurpleDiscoList *list)
+{
+        g_return_if_fail(list != NULL);
+        g_return_if_fail(list->ref > 0);
+
+        list->ref--;
+
+        purple_debug_misc("disco", "unreffing list, ref count now %d\n", list->ref);
+        if (list->ref == 0)
+                purple_disco_list_destroy(list);
+}
+
+void purple_disco_list_service_add(PurpleDiscoList *list, PurpleDiscoService *service, PurpleDiscoService *parent)
+{
+        g_return_if_fail(list != NULL);
+        g_return_if_fail(service != NULL);
+
+        list->services = g_list_append(list->services, service);
+        service->list = list;
+
+        if (ops && ops->add_service)
+                ops->add_service(list, service, parent);
+}
+
+PurpleDiscoService *purple_disco_list_service_new(PurpleDiscoServiceCategory category, const gchar *name,
+                PurpleDiscoServiceType type, const gchar *description, int flags)
+{
+        PurpleDiscoService *s;
+
+        g_return_val_if_fail(name != NULL, NULL);
+
+        s = g_new0(PurpleDiscoService, 1);
+        s->category = category;
+        s->name = g_strdup(name);
+        s->type = type;
+        s->description = g_strdup(description);
+        s->flags = flags;
+
+        return s;
+}
+
+void purple_disco_get_list(PurpleConnection *gc, PurpleDiscoList *list)
+{
+        PurplePlugin *prpl = NULL;
+        PurplePluginProtocolInfo *prpl_info = NULL;
+
+        g_return_if_fail(gc != NULL);
+
+        prpl = purple_connection_get_prpl(gc);
+
+        if (prpl != NULL)
+                prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(prpl);
+
+        if (prpl_info && PURPLE_PROTOCOL_PLUGIN_HAS_FUNC(prpl_info, disco_get_list))
+                prpl_info->disco_get_list(gc, list);
+}
+
+void purple_disco_cancel_get_list(PurpleDiscoList *list)
+{
+        PurplePlugin *prpl = NULL;
+        PurplePluginProtocolInfo *prpl_info = NULL;
+        PurpleConnection *gc;
+
+        g_return_if_fail(list != NULL);
+
+        gc = purple_account_get_connection(list->account);
+
+        g_return_if_fail(gc != NULL);
+
+        if (gc)
+                prpl = purple_connection_get_prpl(gc);
+
+        if (prpl)
+                prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(prpl);
+
+        if (prpl_info && PURPLE_PROTOCOL_PLUGIN_HAS_FUNC(prpl_info, disco_cancel))
+                prpl_info->disco_cancel(list);
+}
+
+int purple_disco_service_register(PurpleConnection *gc, PurpleDiscoService *service)
+{
+        PurplePlugin *prpl = NULL;
+        PurplePluginProtocolInfo *prpl_info = NULL;
+
+        g_return_val_if_fail(gc != NULL, -EINVAL);
+
+        prpl = purple_connection_get_prpl(gc);
+
+        if (prpl != NULL)
+                prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(prpl);
+
+        if (prpl_info && PURPLE_PROTOCOL_PLUGIN_HAS_FUNC(prpl_info, disco_service_register))
+                return prpl_info->disco_service_register(gc, service);
+
+        return -EINVAL;
+}
+
+void purple_disco_set_in_progress(PurpleDiscoList *list, gboolean in_progress)
+{
+        g_return_if_fail(list != NULL);
+
+        list->in_progress = in_progress;
+
+        if (ops && ops->in_progress)
+                ops->in_progress(list, in_progress);
+}
+
+gboolean purple_disco_get_in_progress(PurpleDiscoList *list)
+{
+        g_return_val_if_fail(list != NULL, FALSE);
+
+        return list->in_progress;
+}
+
+void purple_disco_list_set_account(PurpleDiscoList *list, PurpleAccount *account)
+{
+        list->account = account;
+}
+
+PurpleAccount* purple_disco_list_get_account(PurpleDiscoList *list)
+{
+        return list->account;
+}
+
+GList* spurple_disco_list_get_services(PurpleDiscoList *dl)
+{
+        return dl->services;
+}
+
+void purple_disco_list_set_ui_data(PurpleDiscoList *list, gpointer ui_data)
+{
+        list->ui_data = ui_data;
+}
+
+gpointer purple_disco_list_get_ui_data(PurpleDiscoList *list)
+{
+        return list->ui_data;
+}
+
+void purple_disco_list_set_in_progress(PurpleDiscoList *list, gboolean in_progress)
+{
+        list->in_progress = in_progress;
+}
+
+gboolean purple_disco_list_get_in_progress(PurpleDiscoList *list) 
+{
+        return list->in_progress;
+}
+
+void purple_disco_list_set_fetch_count(PurpleDiscoList *list, gint fetch_count)
+{
+        list->fetch_count = fetch_count;
+        purple_debug_info("disco", "fetch_count = %d\n", fetch_count);
+}
+
+gint purple_disco_list_get_fetch_count(PurpleDiscoList *list)
+{
+        return list->fetch_count;
+}
+
+void purple_disco_list_set_proto_data(PurpleDiscoList *list, gpointer proto_data)
+{
+        list->proto_data = proto_data;
+}
+
+gpointer purple_disco_list_get_proto_data(PurpleDiscoList *list)
+{
+        return list->proto_data;
+}
+
+void purple_disco_set_ui_ops(PurpleDiscoUiOps *ui_ops)
+{
+        ops = ui_ops;
+}

--- libpurple/disco.h 12a480589341ae81d963f919dbf030d7a6ef689b
+++ libpurple/disco.h 12a480589341ae81d963f919dbf030d7a6ef689b
@@ -0,0 +1,232 @@
+/**
+ * @file disco.h Service Discovery API
+ * @ingroup core
+ */
+
+/* purple
+ *
+ * Purple is the legal property of its developers, whose names are too numerous
+ * to list here.  Please refer to the COPYRIGHT file distributed with this
+ * source distribution.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111-1301  USA
+ */
+
+#ifndef _PURPLE_DISCO_H_
+#define _PURPLE_DISCO_H_
+
+
+typedef struct _PurpleDiscoList PurpleDiscoList;
+typedef struct _PurpleDiscoService PurpleDiscoService;
+typedef struct _PurpleDiscoUiOps PurpleDiscoUiOps;
+
+#include "account.h"
+
+/**
+ * Represents a list of services for a given connection on a given protocol.
+ */
+struct _PurpleDiscoList {
+        PurpleAccount *account; /**< The account this list belongs to. */
+        GList *services; /**< The list of services. */
+        gpointer *ui_data; /**< UI private data. */
+        gboolean in_progress;
+        gint fetch_count; /**< Uses in fetch processes */
+        gpointer proto_data; /** Prpl private data. */
+        guint ref; /**< The reference count. */
+};
+
+/**
+ * The categories of services.
+ */
+typedef enum
+{
+        PURPLE_DISCO_SERVICE_CAT_NONE,          /**< Other category */
+        PURPLE_DISCO_SERVICE_CAT_GATEWAY,
+        PURPLE_DISCO_SERVICE_CAT_DIRECTORY,
+        PURPLE_DISCO_SERVICE_CAT_MUC
+} PurpleDiscoServiceCategory;
+
+/**
+ * The types of services.
+ */
+typedef enum
+{
+        PURPLE_DISCO_SERVICE_TYPE_NONE,
+        PURPLE_DISCO_SERVICE_TYPE_XMPP,
+        PURPLE_DISCO_SERVICE_TYPE_ICQ,
+        PURPLE_DISCO_SERVICE_TYPE_MAIL,
+        PURPLE_DISCO_SERVICE_TYPE_USER,
+        PURPLE_DISCO_SERVICE_TYPE_YAHOO,
+        PURPLE_DISCO_SERVICE_TYPE_GTALK,
+        PURPLE_DISCO_SERVICE_TYPE_IRC,
+        PURPLE_DISCO_SERVICE_TYPE_GG,
+        PURPLE_DISCO_SERVICE_TYPE_AIM,
+        PURPLE_DISCO_SERVICE_TYPE_QQ,
+        PURPLE_DISCO_SERVICE_TYPE_MSN
+} PurpleDiscoServiceType;
+
+/**
+ * The flags of services.
+ */
+#define PURPLE_DISCO_FLAG_NONE                  0
+#define PURPLE_DISCO_FLAG_ADD                   1 << 0
+#define PURPLE_DISCO_FLAG_BROWSE                1 << 1
+#define PURPLE_DISCO_FLAG_REGISTER              1 << 2
+
+/**
+ * Represents a list of services for a given connection on a given protocol.
+ */
+struct _PurpleDiscoService {
+        PurpleDiscoList *list;
+        PurpleDiscoServiceCategory category; /**< The category of service. */
+        gchar *name; /**< The name of the service. */
+        PurpleDiscoServiceType type; /**< The type of service. */
+        guint flags;
+        gchar *description; /**< The name of the service. */
+};
+
+struct _PurpleDiscoUiOps {
+        void (*dialog_show_with_account)(PurpleAccount* account); /**< Force the ui to pop up a dialog */
+        void (*create)(PurpleDiscoList *list); /**< Init ui resources */
+        void (*destroy)(PurpleDiscoList *list); /**< Free ui resources */
+        void (*add_service)(PurpleDiscoList *list, PurpleDiscoService *service, PurpleDiscoService *parent); /**< Add service to dialog */
+        void (*in_progress)(PurpleDiscoList *list, gboolean in_progress); /**< Set progress to dialog */
+};
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Returns a newly created service discovery object.
+ *
+ * It has an initial reference count of 1.
+ *
+ * @param account The account that's listing rooms.
+ * @return The new service discovery list handle.
+ */
+PurpleDiscoList *purple_disco_list_new(PurpleAccount *account, void *ui_data);
+
+/**
+ * Increases the reference count on the service discovery list.
+ *
+ * @param list The object to ref.
+ */
+void purple_disco_list_ref(PurpleDiscoList *list);
+
+/**
+ * Decreases the reference count on the service discovery list.
+ *
+ * The room list will be destroyed when this reaches 0.
+ *
+ * @param list The room list object to unref and possibly
+ *             destroy.
+ */
+void purple_disco_list_unref(PurpleDiscoList *list);
+
+/**
+ * Instructs the prpl to start fetching the list.
+ *
+ * @param gc The PurpleConnection to have get a list.
+ *
+ */
+void purple_disco_get_list(PurpleConnection *gc, PurpleDiscoList *list);
+
+/**
+ * Tells the prpl to stop fetching the list.
+ * If this is possible and done, the prpl will
+ * call set_in_progress with @c FALSE and possibly
+ * unref the list if it took a reference.
+ *
+ * @param list The service list to cancel a get_list on.
+ */
+void purple_disco_cancel_get_list(PurpleDiscoList *list);
+
+/**
+ * Create new service object
+ */
+PurpleDiscoService *purple_disco_list_service_new(PurpleDiscoServiceCategory category, const gchar *name,
+                PurpleDiscoServiceType type, const gchar *description, int flags);
+
+/**
+ * Add service to list
+ */
+void purple_disco_list_service_add(PurpleDiscoList *list, PurpleDiscoService *service, PurpleDiscoService *parent);
+
+/**
+ * Set the "in progress" state of the Service Discovery.
+ *
+ * The UI is encouraged to somehow hint to the user
+ * whether or not we're busy downloading a service list or not.
+ *
+ * @param list The service list.
+ * @param in_progress We're downloading it, or we're not.
+ */
+void purple_disco_set_in_progress(PurpleDiscoList *list, gboolean in_progress);
+
+/**
+ * Gets the "in progress" state of the Service Discovery.
+ *
+ * The UI is encouraged to somehow hint to the user
+ * whether or not we're busy downloading a service list or not.
+ *
+ * @param list The service list.
+ * @return True if we're downloading it, or false if we're not.
+ */
+gboolean purple_disco_get_in_progress(PurpleDiscoList *list);
+
+
+/**
+ * Sets the UI operations structure to be used in all purple service discovery.
+ *
+ * @param ops The UI operations structure.
+ */
+void purple_disco_set_ui_ops(PurpleDiscoUiOps *ui_ops);
+
+/**
+ * Register service
+ * @param gc Connection
+ * @param service The service that will be registered
+ */
+int purple_disco_service_register(PurpleConnection *gc, PurpleDiscoService *service);
+
+/**< Set/Get the account this list belongs to. */
+void purple_disco_list_set_account(PurpleDiscoList *list, PurpleAccount *account);
+PurpleAccount* purple_disco_list_get_account(PurpleDiscoList *list);
+
+/**< The list of services. */
+GList* spurple_disco_list_get_services(PurpleDiscoList *dl);
+
+/**< Set/Get UI private data. */
+void purple_disco_list_set_ui_data(PurpleDiscoList *list, gpointer ui_data);
+gpointer purple_disco_list_get_ui_data(PurpleDiscoList *list);
+
+/** Set/Get in progress flag */ 
+void purple_disco_list_set_in_progress(PurpleDiscoList *list, gboolean in_progress);
+gboolean purple_disco_list_get_in_progress(PurpleDiscoList *list);
+
+/** Set/Get fetch counter */
+void purple_disco_list_set_fetch_count(PurpleDiscoList *list, gint fetch_count);
+gint purple_disco_list_get_fetch_count(PurpleDiscoList *list);
+
+/** Set/Get prpl private data. */
+void purple_disco_list_set_proto_data(PurpleDiscoList *list, gpointer proto_data);
+gpointer purple_disco_list_get_proto_data(PurpleDiscoList *list);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _PURPLE_DISCO_H_ */

--- pidgin/gtkdisco.c cb47049a7b18d4f4e5c065df6877ae84839e1804
+++ pidgin/gtkdisco.c cb47049a7b18d4f4e5c065df6877ae84839e1804
@@ -0,0 +1,486 @@
+/**
+ * @file gtkdisco.c GTK+ Service Discovery UI
+ * @ingroup pidgin
+ */
+
+/* pidgin
+ *
+ * Pidgin is the legal property of its developers, whose names are too numerous
+ * to list here.  Please refer to the COPYRIGHT file distributed with this
+ * source distribution.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111-1301  USA
+ */
+
+#include "internal.h"
+#include "pidgin.h"
+#include "gtkutils.h"
+#include "debug.h"
+#include "disco.h"
+
+#include "gtkdisco.h"
+
+typedef struct _PidginDiscoDialog {
+        GtkWidget *window;
+        GtkWidget *account_widget;
+        
+        GtkWidget *sw;
+        GtkWidget *progress;
+        GtkTreeStore *model;
+        GtkWidget *tree;
+        GHashTable *cats; /** Meow. */
+
+        GtkWidget *stop_button;
+        GtkWidget *list_button;
+        GtkWidget *register_button;
+        GtkWidget *add_button;
+        GtkWidget *close_button;
+
+        PurpleAccount *account;
+        PurpleDiscoList *discolist;
+} PidginDiscoDialog;
+
+struct _menu_cb_info {
+        PurpleDiscoList *list;
+        PurpleDiscoService *service;
+};
+
+enum {
+        PIXBUF_COLUMN = 0,
+        NAME_COLUMN,
+        DESCRIPTION_COLUMN,
+        SERVICE_COLUMN,
+        NUM_OF_COLUMNS
+};
+
+static void dialog_select_account_cb(GObject *w, PurpleAccount *account,
+                                     PidginDiscoDialog *dialog)
+{
+        dialog->account = account;
+}
+
+static void register_button_cb(GtkButton *button, PidginDiscoDialog *dialog)
+{
+        struct _menu_cb_info *info = g_object_get_data(G_OBJECT(button), "disco-info");
+        PurpleConnection *gc = purple_account_get_connection(info->list->account);
+
+        purple_disco_service_register(gc, info->service);
+}
+
+static void list_button_cb(GtkButton *button, PidginDiscoDialog *dialog)
+{
+        PurpleConnection *gc;
+
+        gc = purple_account_get_connection(dialog->account);
+        if (!gc)
+                return;
+
+        if (dialog->discolist != NULL)
+                purple_disco_list_unref(dialog->discolist);
+        
+        dialog->discolist = purple_disco_list_new(dialog->account, (void*) dialog);
+
+        purple_disco_get_list(gc, dialog->discolist);
+}
+
+static void add_room_to_blist_cb(GtkButton *button, PidginDiscoDialog *dialog)
+{
+        struct _menu_cb_info *info = g_object_get_data(G_OBJECT(button), "disco-info");
+
+        if (info) {
+                if (info->service->category == PURPLE_DISCO_SERVICE_CAT_MUC)
+                        purple_blist_request_add_chat(info->list->account, NULL, NULL, info->service->name);
+                else
+                        purple_blist_request_add_buddy(info->list->account, info->service->name, NULL, NULL);
+        }
+}
+
+static void
+selection_changed_cb(GtkTreeSelection *selection, PidginDiscoDialog *dialog) 
+{
+        PurpleDiscoService *service;
+        GtkTreeIter iter;
+        GValue val;
+        static struct _menu_cb_info *info;
+
+        if (gtk_tree_selection_get_selected(selection, NULL, &iter)) {
+                val.g_type = 0;
+                gtk_tree_model_get_value(GTK_TREE_MODEL(dialog-> model), &iter, SERVICE_COLUMN, &val);
+                service = g_value_get_pointer(&val);
+                if (!service) {
+                        gtk_widget_set_sensitive(dialog->add_button, FALSE);
+                        gtk_widget_set_sensitive(dialog->register_button, FALSE);
+                        return;
+                }
+
+                info = g_new0(struct _menu_cb_info, 1);
+                info->list = dialog->discolist;
+                info->service = service;
+
+                g_object_set_data(G_OBJECT(dialog->add_button), "disco-info", info);
+                g_object_set_data(G_OBJECT(dialog->register_button), "disco-info", info);
+
+                gtk_widget_set_sensitive(dialog->add_button, service->flags & PURPLE_DISCO_FLAG_ADD);
+                gtk_widget_set_sensitive(dialog->register_button, service->flags & PURPLE_DISCO_FLAG_REGISTER);
+        } else {
+                gtk_widget_set_sensitive(dialog->add_button, FALSE);
+                gtk_widget_set_sensitive(dialog->register_button, FALSE);
+        }
+}
+
+static gint
+delete_win_cb(GtkWidget *w, GdkEventAny *e, gpointer d)
+{
+        PidginDiscoDialog *dialog = d;
+
+        if (dialog->discolist)
+                purple_disco_list_unref(dialog->discolist);
+
+        g_free(dialog);
+
+        return FALSE;
+}
+
+static void stop_button_cb(GtkButton *button, PidginDiscoDialog *dialog)
+{
+        purple_disco_cancel_get_list(dialog->discolist);
+
+        if (dialog->account_widget)
+                gtk_widget_set_sensitive(dialog->account_widget, TRUE);
+
+        gtk_widget_set_sensitive(dialog->stop_button, FALSE);
+        gtk_widget_set_sensitive(dialog->list_button, TRUE);
+        gtk_widget_set_sensitive(dialog->add_button, FALSE);
+}
+
+static void close_button_cb(GtkButton *button, PidginDiscoDialog *dialog)
+{
+        GtkWidget *window = dialog->window;
+
+        delete_win_cb(NULL, NULL, dialog);
+        gtk_widget_destroy(window);
+}
+
+static gboolean account_filter_func(PurpleAccount *account)
+{
+        PurpleConnection *conn = purple_account_get_connection(account);
+        PurplePluginProtocolInfo *prpl_info = NULL;
+
+        if (conn)
+                prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(conn->prpl);
+
+        return (prpl_info && PURPLE_PROTOCOL_PLUGIN_HAS_FUNC(prpl_info, disco_get_list));
+}
+
+gboolean
+pidgin_disco_is_showable()
+{
+        GList *c;
+        PurpleConnection *gc;
+
+        for (c = purple_connections_get_all(); c != NULL; c = c->next) {
+                gc = c->data;
+
+                if (account_filter_func(purple_connection_get_account(gc)))
+                        return TRUE;
+        }
+
+        return FALSE;
+}
+
+static void pidgin_disco_create_tree(PidginDiscoDialog *dialog)
+{
+        GtkCellRenderer *text_renderer, *pixbuf_renderer;
+        GtkTreeViewColumn *column;
+        GtkTreeSelection *selection;
+
+        dialog->model = gtk_tree_store_new(NUM_OF_COLUMNS,
+                        GDK_TYPE_PIXBUF,        /* PIXBUF_COLUMN */
+                        G_TYPE_STRING,          /* NAME_COLUMN */
+                        G_TYPE_STRING,          /* DESCRIPTION_COLUMN */
+                        G_TYPE_POINTER          /* SERVICE_COLUMN */
+        );
+
+        dialog->tree = gtk_tree_view_new_with_model(GTK_TREE_MODEL(dialog->model));
+        gtk_tree_view_set_rules_hint(GTK_TREE_VIEW(dialog->tree), TRUE);
+
+        selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(dialog->tree));
+        g_signal_connect(G_OBJECT(selection), "changed",
+                                         G_CALLBACK(selection_changed_cb), dialog);
+
+        g_object_unref(dialog->model);
+
+        gtk_container_add(GTK_CONTAINER(dialog->sw), dialog->tree);
+        gtk_widget_show(dialog->tree);
+
+        text_renderer = gtk_cell_renderer_text_new();
+        pixbuf_renderer = gtk_cell_renderer_pixbuf_new();
+        
+        column = gtk_tree_view_column_new();
+        gtk_tree_view_column_set_title(column, _("Name"));
+
+        gtk_tree_view_column_pack_start(column,  pixbuf_renderer, FALSE);
+        gtk_tree_view_column_set_attributes(column, pixbuf_renderer,
+                        "pixbuf", PIXBUF_COLUMN, NULL);
+
+        gtk_tree_view_column_pack_start(column, text_renderer, TRUE);
+        gtk_tree_view_column_set_attributes(column, text_renderer,
+                        "text", NAME_COLUMN, NULL);
+
+        gtk_tree_view_column_set_sizing(GTK_TREE_VIEW_COLUMN(column),
+                                        GTK_TREE_VIEW_COLUMN_GROW_ONLY);
+        gtk_tree_view_column_set_resizable(GTK_TREE_VIEW_COLUMN(column), TRUE);
+        gtk_tree_view_column_set_sort_column_id(GTK_TREE_VIEW_COLUMN(column), NAME_COLUMN);
+        gtk_tree_view_column_set_reorderable(GTK_TREE_VIEW_COLUMN(column), TRUE);
+        gtk_tree_view_append_column(GTK_TREE_VIEW(dialog->tree), column);
+
+        column = gtk_tree_view_column_new_with_attributes(_("Description"), text_renderer,
+                                "text", DESCRIPTION_COLUMN, NULL);
+        gtk_tree_view_column_set_sizing(GTK_TREE_VIEW_COLUMN(column),
+                                        GTK_TREE_VIEW_COLUMN_GROW_ONLY);
+        gtk_tree_view_column_set_resizable(GTK_TREE_VIEW_COLUMN(column), TRUE);
+        gtk_tree_view_column_set_sort_column_id(GTK_TREE_VIEW_COLUMN(column), DESCRIPTION_COLUMN);
+        gtk_tree_view_column_set_reorderable(GTK_TREE_VIEW_COLUMN(column), TRUE);
+        gtk_tree_view_append_column(GTK_TREE_VIEW(dialog->tree), column);
+}
+
+static PidginDiscoDialog*
+pidgin_disco_dialog_new_with_account(PurpleAccount *account)
+{
+        PidginDiscoDialog *dialog;
+        GtkWidget *window, *vbox, *vbox2, *bbox;
+
+        dialog = g_new0(PidginDiscoDialog, 1);
+        dialog->account = account;
+
+        /* Create the window. */
+        dialog->window = window = pidgin_create_dialog(_("Service Discovery"), PIDGIN_HIG_BORDER, "service discovery", TRUE);
+
+        g_signal_connect(G_OBJECT(window), "delete_event",
+                                         G_CALLBACK(delete_win_cb), dialog);
+
+        /* Create the parent vbox for everything. */
+        vbox = pidgin_dialog_get_vbox_with_properties(GTK_DIALOG(window), FALSE, PIDGIN_HIG_BORDER);
+
+        vbox2 = gtk_vbox_new(FALSE, PIDGIN_HIG_BORDER);
+        gtk_container_add(GTK_CONTAINER(vbox), vbox2);
+        gtk_widget_show(vbox2);
+
+        /* accounts dropdown list */
+        dialog->account_widget = pidgin_account_option_menu_new(dialog->account, FALSE,
+                                 G_CALLBACK(dialog_select_account_cb), account_filter_func, dialog);
+        if (!dialog->account) /* this is normally null, and we normally don't care what the first selected item is */
+                dialog->account = pidgin_account_option_menu_get_selected(dialog->account_widget);
+        pidgin_add_widget_to_vbox(GTK_BOX(vbox2), _("_Account:"), NULL, dialog->account_widget, TRUE, NULL);
+
+        /* scrolled window */
+        dialog->sw = gtk_scrolled_window_new(NULL, NULL);
+        gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(dialog->sw),
+                                            GTK_SHADOW_IN);
+        gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(dialog->sw),
+                                       GTK_POLICY_AUTOMATIC,
+                                       GTK_POLICY_AUTOMATIC);
+        gtk_box_pack_start(GTK_BOX(vbox2), dialog->sw, TRUE, TRUE, 0);
+        gtk_widget_set_size_request(dialog->sw, -1, 250);
+        gtk_widget_show(dialog->sw);
+
+        /* progress bar */
+        dialog->progress = gtk_progress_bar_new();
+        gtk_progress_bar_set_pulse_step(GTK_PROGRESS_BAR(dialog->progress), 0.1);
+        gtk_box_pack_start(GTK_BOX(vbox2), dialog->progress, FALSE, FALSE, 0);
+        gtk_widget_show(dialog->progress);
+
+
+        /* button box */
+        bbox = pidgin_dialog_get_action_area(GTK_DIALOG(window));
+        gtk_box_set_spacing(GTK_BOX(bbox), PIDGIN_HIG_BOX_SPACE);
+        gtk_button_box_set_layout(GTK_BUTTON_BOX(bbox), GTK_BUTTONBOX_END);
+
+        /* stop button */
+        dialog->stop_button = pidgin_dialog_add_button(GTK_DIALOG(window), GTK_STOCK_STOP,
+                         G_CALLBACK(stop_button_cb), dialog);
+        gtk_widget_set_sensitive(dialog->stop_button, FALSE);
+
+        /* list button */
+        dialog->list_button = pidgin_pixbuf_button_from_stock(_("_Get List"), GTK_STOCK_REFRESH,
+                                                            PIDGIN_BUTTON_HORIZONTAL);
+        gtk_box_pack_start(GTK_BOX(bbox), dialog->list_button, FALSE, FALSE, 0);
+        g_signal_connect(G_OBJECT(dialog->list_button), "clicked",
+                         G_CALLBACK(list_button_cb), dialog);
+        gtk_widget_show(dialog->list_button);
+
+        /* register button */
+        dialog->register_button = pidgin_dialog_add_button(GTK_DIALOG(dialog->window), _("Register"),
+                         G_CALLBACK(register_button_cb), dialog);
+        gtk_widget_set_sensitive(dialog->register_button, FALSE);
+
+        /* add button */
+        dialog->add_button = pidgin_pixbuf_button_from_stock(_("_Add"), GTK_STOCK_ADD,
+                                                            PIDGIN_BUTTON_HORIZONTAL);
+        gtk_box_pack_start(GTK_BOX(bbox), dialog->add_button, FALSE, FALSE, 0);
+        g_signal_connect(G_OBJECT(dialog->add_button), "clicked",
+                         G_CALLBACK(add_room_to_blist_cb), dialog);
+        gtk_widget_set_sensitive(dialog->add_button, FALSE);
+        gtk_widget_show(dialog->add_button);
+
+        /* close button */
+        dialog->close_button = pidgin_dialog_add_button(GTK_DIALOG(window), GTK_STOCK_CLOSE,
+                                         G_CALLBACK(close_button_cb), dialog);
+
+        pidgin_disco_create_tree(dialog);
+
+        /* show the dialog window and return the dialog */
+        gtk_widget_show(dialog->window);
+
+        return dialog;
+}
+
+void
+pidgin_disco_dialog_show(void)
+{
+        pidgin_disco_dialog_new_with_account(NULL);
+}
+
+void
+pidgin_disco_dialog_show_with_account(PurpleAccount* account)
+{
+        PidginDiscoDialog *dialog = pidgin_disco_dialog_new_with_account(account);
+
+        if (!dialog)
+                return;
+
+        list_button_cb(GTK_BUTTON(dialog->list_button), dialog);
+}
+
+static void
+pidgin_disco_create(PurpleDiscoList *list)
+{
+        PidginDiscoDialog *dialog = (PidginDiscoDialog *) list->ui_data;
+
+        dialog->cats = g_hash_table_new_full(NULL, NULL, NULL, (GDestroyNotify)gtk_tree_row_reference_free);
+}
+
+
+static void
+pidgin_disco_destroy(PurpleDiscoList *list)
+{
+        PidginDiscoDialog *dialog = (PidginDiscoDialog *) list->ui_data;
+
+        g_hash_table_destroy(dialog->cats);
+}
+
+static void pidgin_disco_in_progress(PurpleDiscoList *list, gboolean in_progress)
+{
+        PidginDiscoDialog *dialog = (PidginDiscoDialog *) list->ui_data;
+
+        if (!dialog)
+                return;
+
+        if (in_progress) {
+                gtk_tree_store_clear(dialog->model);
+                if (dialog->account_widget)
+                        gtk_widget_set_sensitive(dialog->account_widget, FALSE);
+                gtk_widget_set_sensitive(dialog->stop_button, TRUE);
+                gtk_widget_set_sensitive(dialog->list_button, FALSE);
+        } else {
+                gtk_progress_bar_set_fraction(GTK_PROGRESS_BAR(dialog->progress), 0.0);
+                if (dialog->account_widget)
+                        gtk_widget_set_sensitive(dialog->account_widget, TRUE);
+                gtk_widget_set_sensitive(dialog->stop_button, FALSE);
+                gtk_widget_set_sensitive(dialog->list_button, TRUE);
+        }
+}
+
+static void pidgin_disco_add_service(PurpleDiscoList *list, PurpleDiscoService *service, PurpleDiscoService *parent)
+{
+        PidginDiscoDialog *dialog = (PidginDiscoDialog *) list->ui_data;
+        GtkTreeIter iter, parent_iter;
+        GtkTreeRowReference *rr;
+        GtkTreePath *path;
+        char *filename = NULL;
+        GdkPixbuf *pixbuf = NULL;
+
+        purple_debug_info("disco", "Add_service \"%s\"\n", service->name);
+
+        gtk_progress_bar_pulse(GTK_PROGRESS_BAR(dialog->progress));
+
+        if (parent) {
+                rr = g_hash_table_lookup(dialog->cats, parent);
+                path = gtk_tree_row_reference_get_path(rr);
+                if (path) {
+                        gtk_tree_model_get_iter(GTK_TREE_MODEL(dialog->model), &parent_iter, path);
+                        gtk_tree_path_free(path);
+                }
+        }
+
+        gtk_tree_store_append(dialog->model, &iter, (parent ? &parent_iter : NULL));
+        
+        if (service->type == PURPLE_DISCO_SERVICE_TYPE_XMPP)
+                filename = g_build_filename(DATADIR, "pixmaps", "pidgin", "protocols", "22", "jabber.png", NULL);
+        else if (service->type == PURPLE_DISCO_SERVICE_TYPE_ICQ)
+                filename = g_build_filename(DATADIR, "pixmaps", "pidgin", "protocols", "22", "icq.png", NULL);
+        else if (service->type == PURPLE_DISCO_SERVICE_TYPE_YAHOO)
+                filename = g_build_filename(DATADIR, "pixmaps", "pidgin", "protocols", "22", "yahoo.png", NULL);
+        else if (service->type == PURPLE_DISCO_SERVICE_TYPE_GTALK)
+                filename = g_build_filename(DATADIR, "pixmaps", "pidgin", "protocols", "22", "google-talk.png", NULL);
+        else if (service->type == PURPLE_DISCO_SERVICE_TYPE_IRC)
+                filename = g_build_filename(DATADIR, "pixmaps", "pidgin", "protocols", "22", "irc.png", NULL);
+        else if (service->type == PURPLE_DISCO_SERVICE_TYPE_GG)
+                filename = g_build_filename(DATADIR, "pixmaps", "pidgin", "protocols", "22", "gadu-gadu.png", NULL);
+        else if (service->type == PURPLE_DISCO_SERVICE_TYPE_AIM)
+                filename = g_build_filename(DATADIR, "pixmaps", "pidgin", "protocols", "22", "aim.png", NULL);
+        else if (service->type == PURPLE_DISCO_SERVICE_TYPE_QQ)
+                filename = g_build_filename(DATADIR, "pixmaps", "pidgin", "protocols", "22", "qq.png", NULL);
+        else if (service->type == PURPLE_DISCO_SERVICE_TYPE_MSN)
+                filename = g_build_filename(DATADIR, "pixmaps", "pidgin", "protocols", "22", "msn.png", NULL);
+        else if (service->type == PURPLE_DISCO_SERVICE_TYPE_USER)
+                filename = g_build_filename(DATADIR, "pixmaps", "pidgin", "status", "22", "person.png", NULL);
+        else if (service->category == PURPLE_DISCO_SERVICE_CAT_MUC)
+                filename = g_build_filename(DATADIR, "pixmaps", "pidgin", "status", "22", "chat.png", NULL);
+
+        if (filename) {
+                pixbuf = gdk_pixbuf_new_from_file(filename, NULL);
+                g_free(filename);
+        }
+
+        gtk_tree_store_set(dialog->model, &iter,
+                        PIXBUF_COLUMN, pixbuf,
+                        NAME_COLUMN, service->name,
+                        DESCRIPTION_COLUMN, service->description,
+                        SERVICE_COLUMN, service,
+                        -1);
+
+        path = gtk_tree_model_get_path(GTK_TREE_MODEL(dialog->model), &iter);
+
+        rr = gtk_tree_row_reference_new(GTK_TREE_MODEL(dialog->model), path);
+        g_hash_table_insert(dialog->cats, service, rr);
+
+        gtk_tree_path_free(path);
+
+        if (pixbuf)
+                g_object_unref(pixbuf);
+}
+
+static PurpleDiscoUiOps ops = {
+        pidgin_disco_dialog_show_with_account,
+        pidgin_disco_create,
+        pidgin_disco_destroy,
+        pidgin_disco_add_service,
+        pidgin_disco_in_progress
+};
+
+void pidgin_disco_init() {
+        purple_disco_set_ui_ops(&ops);
+}

--- pidgin/gtkdisco.h 1e643fc20a98b6c11e0038da0d8e9270b56dde33
+++ pidgin/gtkdisco.h 1e643fc20a98b6c11e0038da0d8e9270b56dde33
@@ -0,0 +1,56 @@
+/**
+ * @file gtkdisco.c GTK+ Service Discovery UI
+ * @ingroup pidgin
+ */
+
+/* pidgin
+ *
+ * Pidgin is the legal property of its developers, whose names are too numerous
+ * to list here.  Please refer to the COPYRIGHT file distributed with this
+ * source distribution.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111-1301  USA
+ */
+
+#ifndef _GTK_DISCO_H_
+#define _GTK_DISCO_H_
+
+
+/**
+ * Initializes the service discovery subsystem.
+ */
+void pidgin_disco_init(void);
+
+/**
+ * Determines if showing the service discovery dialog is a valid action.
+ *
+ * @return TRUE if there are accounts online that support service
+ *         discovery.  Otherwise return FALSE.
+ */
+gboolean pidgin_disco_is_showable(void);
+
+/**
+ * Shows a new service discovery dialog.
+ */
+void pidgin_disco_dialog_show(void);
+
+/**
+ * Shows a new service discovery dialog and fetches the list for the specified account.
+ *
+ * @param account The account to use.
+ */
+void pidgin_disco_dialog_show_with_account(PurpleAccount *account);
+
+#endif /* _GTK_DISCO_H_ */

--- finch/gntui.c 0a3dd5b122adf23040adadd21949a5ea7e51683d
+++ finch/gntui.c d118c20ec0349bdc2b40f90379365804dec6a830
@@ -91,6 +91,9 @@
	finch_roomlist_init();
	purple_roomlist_set_ui_ops(finch_roomlist_get_ui_ops());

+	/* Finch don't have service discovery UI */
+	purple_disco_set_ui_ops(NULL);
+
	gnt_register_action(_("Accounts"), finch_accounts_show_all);
	gnt_register_action(_("Buddy List"), finch_blist_show);
	gnt_register_action(_("Buddy Pounces"), finch_pounces_manager_show);

--- libpurple/Makefile.am ea431ecfb45e9b1e546b7f8dd0d012a98bb1aaf7
+++ libpurple/Makefile.am 687239120dd3f71d520ee0bae26095744e228b20
@@ -65,6 +65,7 @@
	prpl.c \
	request.c \
	roomlist.c \
+	disco.c \
	savedstatuses.c \
	server.c \
	signals.c \
@@ -118,6 +119,7 @@
	prpl.h \
	request.h \
	roomlist.h \
+	disco.h \
	savedstatuses.h \
	server.h \
	signals.h \
@@ -155,7 +157,7 @@
 dbus_headers  = dbus-bindings.h dbus-purple.h dbus-server.h dbus-useful.h dbus-define-api.h dbus-types.h

 dbus_exported = dbus-useful.h dbus-define-api.h account.h blist.h buddyicon.h \
-                connection.h conversation.h core.h ft.h log.h notify.h prefs.h roomlist.h \
+                connection.h conversation.h core.h ft.h log.h notify.h prefs.h roomlist.h disco.h \
                 savedstatuses.h smiley.h status.h server.h util.h xmlnode.h prpl.h

 purple_build_coreheaders = $(addprefix $(srcdir)/, $(purple_coreheaders)) \
--- libpurple/Makefile.mingw b2ff98bfc1a3f857f03e3b3c6f337ed251d07635
+++ libpurple/Makefile.mingw 677c5b3e5408027f5a1d8411705aa9e4840ce100
@@ -42,6 +42,7 @@
			debug.c \
			dnsquery.c \
			dnssrv.c \
+			disco.c \
			eventloop.c \
			ft.c \
			circbuffer.c \

--- libpurple/protocols/jabber/disco.c 15e05aeaa2b1e64bc8b77794391c734d82691a3e
+++ libpurple/protocols/jabber/disco.c 4e8b89e320ee1d783536d45979aa37777b650239
@@ -1,5 +1,5 @@
 /*
- * purple - Jabber Protocol Plugin
+ * purple - Jabber Service Discovery
  *
  * Copyright (C) 2003, Nathan Walp <faceprint@faceprint.com>
  *
@@ -22,6 +22,8 @@
 #include "internal.h"
 #include "prefs.h"
 #include "debug.h"
+#include "request.h"
+#include "notify.h"

 #include "buddy.h"
 #include "google.h"
@@ -32,8 +34,9 @@
 #include "roster.h"
 #include "pep.h"
 #include "adhoccommands.h"
+#include "xdata.h"
+#include "libpurple/disco.h"

-
 struct _jabber_disco_info_cb_data {
	gpointer data;
	JabberDiscoInfoCallback *callback;
@@ -270,6 +273,8 @@
					capabilities |= JABBER_CAP_IQ_REGISTER;
				else if(!strcmp(var, "http://www.xmpp.org/extensions/xep-0199.html#ns"))
					capabilities |= JABBER_CAP_PING;
+				else if(!strcmp(var, "http://jabber.org/protocol/disco#items"))
+					capabilities |= JABBER_CAP_ITEMS;
				else if(!strcmp(var, "http://jabber.org/protocol/commands")) {
					capabilities |= JABBER_CAP_ADHOC;
				}
@@ -309,7 +314,8 @@
 	}
 }
 
-void jabber_disco_items_parse(JabberStream *js, xmlnode *packet) {
+void jabber_disco_items_parse(JabberStream *js, xmlnode *packet)
+{
	const char *from = xmlnode_get_attrib(packet, "from");
	const char *type = xmlnode_get_attrib(packet, "type");
 
@@ -394,6 +400,12 @@
 
 }
 
+struct _disco_data {
+        PurpleDiscoList *list;
+        PurpleDiscoService *parent;
+        char *node;
+};
+
 static void
 jabber_disco_server_info_result_cb(JabberStream *js, xmlnode *packet, gpointer data)
 {
@@ -556,4 +568,366 @@
	jabber_iq_send(iq);
 }
 
+static PurpleDiscoServiceCategory
+jabber_disco_category_from_string(const gchar *str)
+{
+        if (!strcasecmp(str, "gateway"))
+                return PURPLE_DISCO_SERVICE_CAT_GATEWAY;
+        else if (!strcasecmp(str, "directory"))
+                return PURPLE_DISCO_SERVICE_CAT_DIRECTORY;
+        else if (!strcasecmp(str, "conference"))
+                return PURPLE_DISCO_SERVICE_CAT_MUC;
 
+        return PURPLE_DISCO_SERVICE_CAT_NONE;
+}
+
+static PurpleDiscoServiceType
+jabber_disco_type_from_string(const gchar *str)
+{
+        if (!strcasecmp(str, "xmpp"))
+                return PURPLE_DISCO_SERVICE_TYPE_XMPP;
+        else if (!strcasecmp(str, "icq"))
+                return PURPLE_DISCO_SERVICE_TYPE_ICQ;
+        else if (!strcasecmp(str, "mrim"))
+                return PURPLE_DISCO_SERVICE_TYPE_MAIL;
+        else if (!strcasecmp(str, "user"))
+                return PURPLE_DISCO_SERVICE_TYPE_USER;
+        else if (!strcasecmp(str, "yahoo"))
+                return PURPLE_DISCO_SERVICE_TYPE_YAHOO;
+        else if (!strcasecmp(str, "irc"))
+                return PURPLE_DISCO_SERVICE_TYPE_IRC;
+        else if (!strcasecmp(str, "gadu-gadu"))
+                return PURPLE_DISCO_SERVICE_TYPE_GG;
+        else if (!strcasecmp(str, "aim"))
+                return PURPLE_DISCO_SERVICE_TYPE_AIM;
+        else if (!strcasecmp(str, "qq"))
+                return PURPLE_DISCO_SERVICE_TYPE_QQ;
+        else if (!strcasecmp(str, "msn"))
+                return PURPLE_DISCO_SERVICE_TYPE_MSN;
+
+        return PURPLE_DISCO_SERVICE_TYPE_NONE;
+}
+
+static void
+jabber_disco_service_info_cb(JabberStream *js, xmlnode *packet, gpointer data);
+
+static void
+jabber_disco_service_items_cb(JabberStream *js, xmlnode *packet, gpointer data)
+{
+        struct _disco_data *disco_data = data;
+        PurpleDiscoList *list = disco_data->list;
+        PurpleDiscoService *parent = disco_data->parent;
+        const char *parent_node = disco_data->node;
+        xmlnode *query = xmlnode_get_child(packet, "query");
+        const char *from = xmlnode_get_attrib(packet, "from");
+        const char *result = xmlnode_get_attrib(packet, "type");
+        xmlnode *child;
+        gboolean has_items = FALSE;
+
+        purple_disco_list_set_fetch_count(list, purple_disco_list_get_fetch_count(list) - 1);
+
+        if (!from || !result || !query || (strcmp(result, "result")
+                        || !purple_disco_list_get_proto_data(list))) {
+                if (!purple_disco_list_get_fetch_count(list))
+                        purple_disco_set_in_progress(list, FALSE);
+
+                purple_disco_list_unref(list);
+                return;
+        }
+
+        query = xmlnode_get_child(packet, "query");
+
+        for(child = xmlnode_get_child(query, "item"); child;
+                        child = xmlnode_get_next_twin(child)) {
+                JabberIq *iq;
+                xmlnode *q;
+                const char *jid, *node;
+                struct _disco_data *disco_data;
+                char *full_node;
+
+                if(!(jid = xmlnode_get_attrib(child, "jid")) || !purple_disco_list_get_proto_data(list))
+                        continue;
+
+                node = xmlnode_get_attrib(child, "node");
+
+                if (parent_node) {
+                        if (node) {
+                                full_node = g_new0(char, strlen(parent_node) + 1 + strlen(node) + 1);
+                                strcat(full_node, parent_node);
+                                strcat(full_node, "/");
+                                strcat(full_node, node);
+                        } else {
+                                continue;
+                        }
+                } else {
+                        full_node = g_strdup(node);
+                }
+
+                disco_data = g_new0(struct _disco_data, 1);
+                disco_data->list = list;
+                disco_data->parent = parent;
+                disco_data->node = full_node;
+
+                has_items = TRUE;
+                purple_disco_list_set_fetch_count(list, purple_disco_list_get_fetch_count(list) + 1);
+                purple_disco_list_ref(list);
+                iq = jabber_iq_new_query(js, JABBER_IQ_GET, "http://jabber.org/protocol/disco#info");
+                xmlnode_set_attrib(iq->node, "to", jid);
+                if (full_node && (q = xmlnode_get_child(iq->node, "query")))
+                        xmlnode_set_attrib(q, "node", full_node);
+                jabber_iq_set_callback(iq, jabber_disco_service_info_cb, disco_data);
+
+                jabber_iq_send(iq);
+        }
+
+        if (!purple_disco_list_get_fetch_count(list))
+                purple_disco_set_in_progress(list, FALSE);
+        purple_disco_list_unref(list);
+
+        g_free(disco_data->node);
+        g_free(disco_data);
+}
+
+static void
+jabber_disco_service_info_cb(JabberStream *js, xmlnode *packet, gpointer data)
+{
+        struct _disco_data *disco_data = data;
+        PurpleDiscoList *list = disco_data->list;
+        PurpleDiscoService *parent = disco_data->parent;
+        char *node = g_strdup(disco_data->node);
+        xmlnode *query, *ident, *child;
+        const char *from = xmlnode_get_attrib(packet, "from");
+        const char *result = xmlnode_get_attrib(packet, "type");
+        const char *acat, *atype, *adesc, *anode;
+        char *aname;
+        PurpleDiscoService *s;
+        PurpleDiscoServiceCategory cat;
+        PurpleDiscoServiceType type;
+        int flags = PURPLE_DISCO_FLAG_ADD;
+
+        g_free(disco_data->node);
+        g_free(disco_data);
+        purple_disco_list_set_fetch_count(list, purple_disco_list_get_fetch_count(list) - 1);
+
+        if (!from || !result || (strcmp(result, "result") || !purple_disco_list_get_proto_data(list))
+                        || (!(query = xmlnode_get_child(packet, "query")))
+                        || (!(ident = xmlnode_get_child(query, "identity")))) {
+                if (!purple_disco_list_get_fetch_count(list))
+                        purple_disco_set_in_progress(list, FALSE);
+
+                purple_disco_list_unref(list);
+                return;
+        }
+
+        acat = xmlnode_get_attrib(ident, "category");
+        atype = xmlnode_get_attrib(ident, "type");
+        adesc = xmlnode_get_attrib(ident, "name");
+        anode = xmlnode_get_attrib(query, "node");
+
+        if (anode) {
+                aname = g_new0(char, strlen(from) + strlen(anode) + 1);
+                strcat(aname, from);
+                strcat(aname, anode);
+        } else {
+                aname = g_strdup(from);
+        }
+
+        cat = jabber_disco_category_from_string(acat);
+        type = jabber_disco_type_from_string(atype);
+
+        for (child = xmlnode_get_child(query, "feature"); child;
+                        child = xmlnode_get_next_twin(child)) {
+                const char *var;
+
+                if (!(var = xmlnode_get_attrib(child, "var")))
+                        continue;
+                
+                if (!strcmp(var, "jabber:iq:register"))
+                        flags |= PURPLE_DISCO_FLAG_REGISTER;
+                
+                if (!strcmp(var, "http://jabber.org/protocol/disco#items"))
+                        flags |= PURPLE_DISCO_FLAG_BROWSE;
+
+                if (!strcmp(var, "http://jabber.org/protocol/muc"))
+                        cat = PURPLE_DISCO_SERVICE_CAT_MUC;
+        }
+
+        purple_debug_info("disco", "service %s, category %s (%d), type %s (%d), description %s, flags %04x\n",
+                        aname,
+                        acat, cat,
+                        atype, type,
+                        adesc, flags);
+
+        s = purple_disco_list_service_new(cat, aname, type, adesc, flags);
+        purple_disco_list_service_add(list, s, parent);
+
+        /* if (flags & PURPLE_DISCO_FLAG_BROWSE) - not all browsable services has this future */
+        {
+                xmlnode *q;
+                JabberIq *iq = jabber_iq_new_query(js, JABBER_IQ_GET, "http://jabber.org/protocol/disco#items");
+                        
+                purple_disco_list_set_fetch_count(list, purple_disco_list_get_fetch_count(list) + 1);
+                purple_disco_list_ref(list);
+                disco_data = g_new0(struct _disco_data, 1);
+                disco_data->list = list;
+                disco_data->parent = s;
+
+                xmlnode_set_attrib(iq->node, "to", from);
+                jabber_iq_set_callback(iq, jabber_disco_service_items_cb, disco_data);
+                if (anode && (q = xmlnode_get_child(iq->node, "query")))
+                        xmlnode_set_attrib(q, "node", node);
+                jabber_iq_send(iq);
+        }
+
+        if (!purple_disco_list_get_fetch_count(list))
+                purple_disco_set_in_progress(list, FALSE);
+
+        purple_disco_list_unref(list);
+
+        g_free(aname);
+        g_free(node);
+}
+
+static void
+jabber_disco_server_items_cb(JabberStream *js, xmlnode *packet, gpointer data)
+{
+        PurpleDiscoList *list = data;
+        xmlnode *query, *child;
+        const char *from = xmlnode_get_attrib(packet, "from");
+        const char *type = xmlnode_get_attrib(packet, "type");
+        gboolean has_items = FALSE;
+
+        if (!from || !type)
+                return;
+
+        if (strcmp(type, "result"))
+                return;
+
+        query = xmlnode_get_child(packet, "query");
+
+        for(child = xmlnode_get_child(query, "item"); child;
+                        child = xmlnode_get_next_twin(child)) {
+                JabberIq *iq;
+                const char *jid;
+                struct _disco_data *disco_data;
+
+                if(!(jid = xmlnode_get_attrib(child, "jid")) || !purple_disco_list_get_proto_data(list))
+                        continue;
+
+                disco_data = g_new0(struct _disco_data, 1);
+                disco_data->list = list;
+
+                has_items = TRUE;
+                purple_disco_list_set_fetch_count(list, purple_disco_list_get_fetch_count(list) + 1);
+                purple_disco_list_ref(list);
+                iq = jabber_iq_new_query(js, JABBER_IQ_GET, "http://jabber.org/protocol/disco#info");
+                xmlnode_set_attrib(iq->node, "to", jid);
+                jabber_iq_set_callback(iq, jabber_disco_service_info_cb, disco_data);
+
+                jabber_iq_send(iq);
+        }
+
+        if (!has_items)
+                purple_disco_set_in_progress(list, FALSE);
+
+        purple_disco_list_unref(list);
+}
+
+static void
+jabber_disco_server_info_cb(JabberStream *js, const char *who, JabberCapabilities caps, gpointer data)
+{
+        PurpleDiscoList *list = data;
+        JabberIq *iq;
+
+        if (caps & JABBER_CAP_ITEMS) {
+                iq = jabber_iq_new_query(js, JABBER_IQ_GET, "http://jabber.org/protocol/disco#items");
+                xmlnode_set_attrib(iq->node, "to", who);
+                jabber_iq_set_callback(iq, jabber_disco_server_items_cb, list);
+        
+                if (purple_disco_list_get_proto_data(list))
+                        jabber_iq_send(iq);
+                else
+                        purple_disco_list_unref(list);
+        
+        } else {
+                purple_notify_error(NULL, _("Error"), _("Server don't support service discovery"), NULL); 
+                purple_disco_set_in_progress(list, FALSE);
+                purple_disco_list_unref(list);
+        }
+}
+
+static void
+jabber_disco_server_cb(PurpleDiscoList *list, PurpleRequestFields *fields)
+{
+        const char *server_name;
+
+        purple_disco_set_in_progress(list, TRUE);
+        server_name = purple_request_fields_get_string(fields, "server");
+        purple_debug_misc("jabber", "Service discovery for %s\n", server_name);
+
+        purple_prefs_set_string(DISCO_PREF_LAST_SERVER, server_name);
+
+        if (purple_disco_list_get_proto_data(list)) 
+                jabber_disco_info_do(purple_disco_list_get_proto_data(list),
+                                server_name, jabber_disco_server_info_cb, list);
+}
+
+void
+jabber_disco_get_list(PurpleConnection *gc, PurpleDiscoList *list)
+{
+        PurpleRequestFields *fields;
+        PurpleRequestFieldGroup *g;
+        PurpleRequestField *f;
+        JabberStream *js;
+        const char *last_server =  purple_prefs_get_string(DISCO_PREF_LAST_SERVER);
+
+        purple_debug_misc("disco.c", "get_list\n");
+
+        js = gc->proto_data;
+        purple_disco_list_set_proto_data(list, js);
+
+        fields = purple_request_fields_new();
+        g = purple_request_field_group_new(NULL);
+        f = purple_request_field_string_new("server", _("Server"), 
+                last_server ? last_server : js->user->domain, FALSE);
+
+        purple_request_field_group_add_field(g, f);
+        purple_request_fields_add_group(fields, g);
+        
+        purple_disco_list_ref(list);
+        
+        purple_request_fields(gc,
+                _("Server name request"),
+                _("Enter server name"),
+                NULL,
+                fields,
+                _("OK"), G_CALLBACK(jabber_disco_server_cb),
+                _("Cancel"), NULL,
+                purple_connection_get_account(gc), NULL, NULL, list);
+}
+
+void
+jabber_disco_cancel(PurpleDiscoList *list)
+{
+        purple_disco_list_set_proto_data(list, NULL);
+        purple_disco_set_in_progress(list, FALSE);      
+}
+
+int
+jabber_disco_service_register(PurpleConnection *gc, PurpleDiscoService *service)
+{
+        JabberStream *js = gc->proto_data;
+        
+        jabber_register_gateway(js, service->name);
+
+        return 0;
+}
+
+void jabber_disco_init(void)
+{
+        purple_prefs_add_none("/purple/jabber");
+        purple_prefs_add_none("/purple/jabber/disco");
+
+        purple_prefs_add_string(DISCO_PREF_LAST_SERVER, NULL);
+}
+

--- libpurple/protocols/jabber/disco.h f30f10709e0282c73ff287b1c373440f9ae41e81
+++ libpurple/protocols/jabber/disco.h 29da953b418e804fce3861879702bd64066b496a
@@ -1,5 +1,5 @@
 /**
- * @file iq.h JabberID handlers
+ * @file disco.h Jabber Service Discovery
  *
  * purple
  *
@@ -24,6 +24,10 @@
 
 #include "jabber.h"
 
+#define DISCO_PREF_LAST_SERVER  "/purple/jabber/disco/last_server"
+
+void jabber_disco_init(void);
+
 typedef void (JabberDiscoInfoCallback)(JabberStream *js, const char *who,
		JabberCapabilities capabilities, gpointer data);
 
@@ -35,4 +39,10 @@
 void jabber_disco_info_do(JabberStream *js, const char *who,
		JabberDiscoInfoCallback *callback, gpointer data);
 
+void jabber_disco_get_list(PurpleConnection *gc, PurpleDiscoList* list);
+void jabber_disco_cancel(PurpleDiscoList *list);
+void jabber_disco_get_childs(PurpleConnection *gc, PurpleDiscoService *service);
+
+int jabber_disco_service_register(PurpleConnection *gc, PurpleDiscoService *service);
+
 #endif /* _PURPLE_JABBER_DISCO_H_ */

--- libpurple/protocols/jabber/jabber.c ffa2b86a187b53e8e165af133466d0a7e5251046
+++ libpurple/protocols/jabber/jabber.c bf9735fec8a40e324451d21e28bcdb2dc4440588
@@ -1074,22 +1074,24 @@
	group = purple_request_field_group_new(NULL);
	purple_request_fields_add_group(fields, group);
 
-	if(js->registration)
-		field = purple_request_field_string_new("username", _("Username"), js->user->node, FALSE);
-	else
-		field = purple_request_field_string_new("username", _("Username"), NULL, FALSE);
+	if(xmlnode_get_child(query, "username")) {
+		if(js->registration)
+			field = purple_request_field_string_new("username", _("Username"), js->user->node, FALSE);
+		else
+			field = purple_request_field_string_new("username", _("Username"), NULL, FALSE);
 
-	purple_request_field_group_add_field(group, field);
+		purple_request_field_group_add_field(group, field);
+	}
+	if(xmlnode_get_child(query, "password")) {
+		if(js->registration)
+			field = purple_request_field_string_new("password", _("Password"),
+										purple_connection_get_password(js->gc), FALSE);
+		else
+			field = purple_request_field_string_new("password", _("Password"), NULL, FALSE);
 
-	if(js->registration)
-		field = purple_request_field_string_new("password", _("Password"),
-									purple_connection_get_password(js->gc), FALSE);
-	else
-		field = purple_request_field_string_new("password", _("Password"), NULL, FALSE);
-
-	purple_request_field_string_set_masked(field, TRUE);
-	purple_request_field_group_add_field(group, field);
-
+		purple_request_field_string_set_masked(field, TRUE);
+		purple_request_field_group_add_field(group, field);
+	}
	if(xmlnode_get_child(query, "name")) {
		if(js->registration)
			field = purple_request_field_string_new("name", _("Name"),

--- libpurple/protocols/jabber/jabber.h df574ab651cdebe290c7ce7f0a329167c562919a
+++ libpurple/protocols/jabber/jabber.h b7df523dfc92963b33d884cc339f430c5ca0fd19
@@ -44,6 +44,8 @@
	JABBER_CAP_ADHOC		  = 1 << 12,
	JABBER_CAP_BLOCKING       = 1 << 13,
 
+        JABBER_CAP_ITEMS          = 1 << 14,
+
	JABBER_CAP_RETRIEVED      = 1 << 31
 } JabberCapabilities;
 

--- libpurple/protocols/jabber/libxmpp.c 57be32934eb9f7a99243045cadba2059bcc3a4f4
+++ libpurple/protocols/jabber/libxmpp.c e937ed9f40bff9fe19aa8524179a0ab63883f1ae
@@ -34,6 +34,7 @@
 #include "iq.h"
 #include "jabber.h"
 #include "chat.h"
+#include "disco.h"
 #include "message.h"
 #include "roster.h"
 #include "si.h"
@@ -118,7 +119,11 @@
 	jabber_attention_types,			/* attention_types */
 
 	sizeof(PurplePluginProtocolInfo),       /* struct_size */
-	NULL
+        NULL,
+        jabber_disco_get_list,			/* disco_get_list */
+        jabber_disco_cancel,			/* disco_cancel */
+        jabber_disco_service_register		/* disco_service_register */
+
 };
 
 static gboolean load_plugin(PurplePlugin *plugin)
@@ -280,7 +285,8 @@
 	jabber_caps_init();
 	
 	jabber_data_init();
-	
+	jabber_disco_init();
+
 	jabber_add_feature("avatarmeta", AVATARNAMESPACEMETA, jabber_pep_namespace_only_when_pep_enabled_cb);
 	jabber_add_feature("avatardata", AVATARNAMESPACEDATA, jabber_pep_namespace_only_when_pep_enabled_cb);
 	jabber_add_feature("buzz", "http://www.xmpp.org/extensions/xep-0224.html#ns",
--- libpurple/prpl.h f93c6c9088ab8fd3d2984da02ace7121f7dab5f5
+++ libpurple/prpl.h f8e7474e9d1788e2fb97d9e6ebfd2734f6f054a2
@@ -69,6 +69,7 @@
 #include "proxy.h"
 #include "plugin.h"
 #include "roomlist.h"
+#include "disco.h"
 #include "status.h"
 #include "whiteboard.h"
 
@@ -449,6 +450,21 @@
 	 *         destroyed by the caller when it's no longer needed.
 	 */
 	GHashTable *(*get_account_text_table)(PurpleAccount *account);
+
+        /**
+         * Service discovery prpl callbacks
+         */
+        void (*disco_get_list)(PurpleConnection *gc, PurpleDiscoList *list);
+
+        /**
+         * Cancel fetching service list
+         */
+        void (*disco_cancel)(PurpleDiscoList *list);
+
+        /**
+         * Register service
+         */
+        int (*disco_service_register)(PurpleConnection *gc, PurpleDiscoService *service);
 };
 
 #define PURPLE_PROTOCOL_PLUGIN_HAS_FUNC(prpl, member) \
--- libpurple/purple.h.in 1fa94bd111d8190501cf48321c9b4fd6d2e5261d
+++ libpurple/purple.h.in dea46f95559f744f817499d5d4e480c9a8bd4bce
@@ -79,6 +79,7 @@
 #include <prpl.h>
 #include <request.h>
 #include <roomlist.h>
+#include <disco.h>
 #include <savedstatuses.h>
 #include <server.h>
 #include <signals.h>

--- pidgin/Makefile.am d51a79bde1a00dc66f425cfc3fa80792c80656af
+++ pidgin/Makefile.am 688c7b357b147c28ce57416eb995c79b5ce0375e
@@ -108,6 +108,7 @@
	gtkprivacy.c \
	gtkrequest.c \
	gtkroomlist.c \
+	gtkdisco.c \
	gtksavedstatuses.c \
	gtkscrollbook.c \
	gtksession.c \
@@ -161,6 +162,7 @@
	gtkpounce.h \
	gtkrequest.h \
	gtkroomlist.h \
+	gtkdisco.h \
	gtksavedstatuses.h \
	gtkscrollbook.h \
	gtksession.h \

--- pidgin/Makefile.mingw cd6e78bb6c96ba89595feeffa33c29f7f4d74c26
+++ pidgin/Makefile.mingw 4ee397e1e56cd14e0f6c8a4a7f128b8db05400fa
@@ -63,6 +63,7 @@
			gtkconv.c \
			gtkdebug.c \
			gtkdialogs.c \
+			gtkdisco.c \
			gtkdnd-hints.c \
			gtkdocklet.c \
			gtkeventloop.c \

--- pidgin/gtkblist.c e8f765b444cae9e40419e924045e4e59b67a1e18
+++ pidgin/gtkblist.c 7d7b2fee41ab9307afe901a2b43863c373f93e55
@@ -55,6 +55,7 @@
 #include "gtkprefs.h"
 #include "gtkprivacy.h"
 #include "gtkroomlist.h"
+#include "gtkdisco.h"
 #include "gtkstatusbox.h"
 #include "gtkscrollbook.h"
 #include "gtksmiley.h"
@@ -3293,6 +3294,7 @@
	{ N_("/Tools/Smile_y"), "<CTL>Y", pidgin_smiley_manager_show, 0, "<StockItem>", PIDGIN_STOCK_TOOLBAR_SMILEY },
	{ "/Tools/sep2", NULL, NULL, 0, "<Separator>", NULL },
	{ N_("/Tools/_File Transfers"), "<CTL>T", pidgin_xfer_dialog_show, 0, "<StockItem>", PIDGIN_STOCK_TOOLBAR_TRANSFER },
+	{ N_("/Tools/Service _Discovery"), NULL, pidgin_disco_dialog_show, 0, "<Item>", NULL },
	{ N_("/Tools/R_oom List"), NULL, pidgin_roomlist_dialog_show, 0, "<Item>", NULL },
	{ N_("/Tools/System _Log"), NULL, gtk_blist_show_systemlog_cb, 3, "<Item>", NULL },
	{ "/Tools/sep3", NULL, NULL, 0, "<Separator>", NULL },
@@ -4153,6 +4155,9 @@
 
	widget = gtk_item_factory_get_widget(gtkblist->ift, N_("/Tools/Room List"));
	gtk_widget_set_sensitive(widget, pidgin_roomlist_is_showable());
+
+	widget = gtk_item_factory_get_widget(gtkblist->ift, N_("/Tools/Service Discovery"));
+	gtk_widget_set_sensitive(widget, pidgin_disco_is_showable());
 }
 
 static void

--- pidgin/gtkmain.c 9969c0180c98f26e1312f35b33092667914b9dea
+++ pidgin/gtkmain.c 13fad327dafb8746dfc36ab5c8f6d2a08dec78b9
@@ -60,6 +60,7 @@
 #include "gtkprivacy.h"
 #include "gtkrequest.h"
 #include "gtkroomlist.h"
+#include "gtkdisco.h"
 #include "gtksavedstatuses.h"
 #include "gtksession.h"
 #include "gtksmiley.h"
@@ -307,6 +308,7 @@
	pidgin_privacy_init();
	pidgin_xfers_init();
	pidgin_roomlist_init();
+	pidgin_disco_init();
	pidgin_log_init();
	pidgin_docklet_init();
	pidgin_smileys_init();
